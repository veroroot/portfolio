name: Build & Deploy (Pages + PDF)

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # ============================
      # 1) Setup Pages
      # ============================
      - name: Setup Pages
        uses: actions/configure-pages@v5     

      # ============================
      # 2) Build GitHub Pages site
      # ============================
      - name: Build GitHub Pages site
        uses: actions/jekyll-build-pages@v1
        with:
          source: .
          destination: ./public

      # ============================
      # 3) Setup Node.js for Puppeteer
      # ============================
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # ============================
      # 4) Install Puppeteer and dependencies
      # ============================
      - name: Install Puppeteer and system dependencies
        run: |
          # Puppeteer 설치 (로컬)
          npm init -y
          npm install puppeteer
          
          # Chrome/Chromium 실행에 필요한 시스템 라이브러리 및 한글 폰트 설치
          # Ubuntu 24.04에서는 libasound2가 libasound2t64로 변경됨
          sudo apt-get update
          sudo apt-get install -y \
            ca-certificates \
            fonts-liberation \
            fonts-noto \
            fonts-noto-cjk \
            fonts-noto-color-emoji \
            libasound2t64 \
            libatk-bridge2.0-0 \
            libatk1.0-0 \
            libc6 \
            libcairo2 \
            libcups2 \
            libdbus-1-3 \
            libexpat1 \
            libfontconfig1 \
            libgbm1 \
            libgcc1 \
            libglib2.0-0 \
            libgtk-3-0 \
            libnspr4 \
            libnss3 \
            libpango-1.0-0 \
            libpangocairo-1.0-0 \
            libstdc++6 \
            libx11-6 \
            libx11-xcb1 \
            libxcb1 \
            libxcomposite1 \
            libxcursor1 \
            libxdamage1 \
            libxext6 \
            libxfixes3 \
            libxi6 \
            libxrandr2 \
            libxrender1 \
            libxss1 \
            libxtst6 \
            lsb-release \
            wget \
            xdg-utils
          
          # 폰트 캐시 업데이트
          sudo fc-cache -fv

      # ============================
      # 5) Generate PDF from HTML (GitHub Pages 스타일)
      # Jekyll로 빌드된 HTML을 Puppeteer로 PDF 변환
      # ============================
      - name: Generate PDF from HTML
        run: |
          # 빌드된 파일 구조 확인 (디버깅)
          echo "=== Public directory structure ==="
          find public -type f -name "*.html" | head -10
          echo ""
          
          # PDF 생성 스크립트 작성
          cat > generate-pdf.js << 'EOF'
          const puppeteer = require('puppeteer');
          const http = require('http');
          const fs = require('fs');
          const path = require('path');
          const url = require('url');
          
          (async () => {
            // 간단한 HTTP 서버 시작 (리소스 로드를 위해)
            const publicDir = path.join(process.cwd(), 'public');
            
            // HTML 파일 찾기
            const possibleFiles = ['README.html', 'index.html'];
            let htmlFile = null;
            for (const file of possibleFiles) {
              const filePath = path.join(publicDir, file);
              if (fs.existsSync(filePath)) {
                htmlFile = file;
                console.log(`Found HTML file: ${file}`);
                break;
              }
            }
            
            if (!htmlFile) {
              // public 디렉토리에서 첫 번째 HTML 파일 찾기
              const files = fs.readdirSync(publicDir);
              htmlFile = files.find(f => f.endsWith('.html'));
              if (!htmlFile) {
                throw new Error('No HTML file found in public directory');
              }
              console.log(`Using HTML file: ${htmlFile}`);
            }
            
            const server = http.createServer((req, res) => {
              let requestPath = url.parse(req.url).pathname;
              
              // Jekyll baseurl 제거 (/portfolio/ prefix 제거)
              if (requestPath.startsWith('/portfolio/')) {
                requestPath = requestPath.substring('/portfolio'.length);
              }
              
              // 루트 경로는 HTML 파일로
              if (requestPath === '/' || requestPath === '') {
                requestPath = '/' + htmlFile;
              }
              
              // URL 디코딩 (한글 파일명 처리)
              try {
                requestPath = decodeURIComponent(requestPath);
              } catch (e) {
                // 디코딩 실패 시 원본 사용
              }
              
              let filePath = path.join(publicDir, requestPath);
              
              // 경로 보안 체크
              if (!filePath.startsWith(publicDir)) {
                res.writeHead(403);
                res.end('Forbidden');
                return;
              }
              
              // 파일 존재 확인
              if (fs.existsSync(filePath) && fs.statSync(filePath).isFile()) {
                const ext = path.extname(filePath).toLowerCase();
                const contentType = {
                  '.html': 'text/html; charset=utf-8',
                  '.css': 'text/css; charset=utf-8',
                  '.js': 'application/javascript; charset=utf-8',
                  '.png': 'image/png',
                  '.jpg': 'image/jpeg',
                  '.jpeg': 'image/jpeg',
                  '.gif': 'image/gif',
                  '.svg': 'image/svg+xml',
                  '.woff': 'font/woff',
                  '.woff2': 'font/woff2',
                  '.ttf': 'font/ttf',
                  '.otf': 'font/otf'
                }[ext] || 'application/octet-stream';
                
                res.writeHead(200, { 
                  'Content-Type': contentType,
                  'Cache-Control': 'no-cache'
                });
                fs.createReadStream(filePath).pipe(res);
              } else {
                console.log(`File not found: ${filePath}`);
                res.writeHead(404);
                res.end('Not found');
              }
            });
            
            await new Promise((resolve) => {
              server.listen(8080, () => {
                console.log('Server started on port 8080');
                resolve();
              });
            });
            
            // Puppeteer로 PDF 생성
            const browser = await puppeteer.launch({
              headless: true,
              args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-gpu',
                '--font-render-hinting=none',
                '--lang=ko-KR,ko'
              ]
            });
            const page = await browser.newPage();
            
            // 한글 폰트 및 언어 설정
            await page.evaluateOnNewDocument(() => {
              Object.defineProperty(navigator, 'languages', {
                get: () => ['ko-KR', 'ko', 'en-US', 'en']
              });
            });
            
            // 로컬 서버의 URL로 접근
            console.log('Loading page: http://localhost:8080/');
            await page.goto('http://localhost:8080/', { 
              waitUntil: 'networkidle0', 
              timeout: 60000 
            });
            
            // HTML 내 경로 수정 (/portfolio/ prefix 제거)
            await page.evaluate(() => {
              // base 태그 제거 또는 수정
              const baseTag = document.querySelector('base');
              if (baseTag && baseTag.href.includes('/portfolio/')) {
                baseTag.href = baseTag.href.replace('/portfolio', '');
              }
              
              // 이미지 태그의 src 속성 수정
              const images = document.querySelectorAll('img');
              images.forEach(img => {
                const src = img.getAttribute('src');
                if (src) {
                  // /portfolio/ prefix 제거
                  if (src.startsWith('/portfolio/')) {
                    img.src = src.substring('/portfolio'.length);
                  } else if (src.startsWith('/portfolio')) {
                    img.src = src.substring('/portfolio'.length) || '/';
                  }
                }
              });
              
              // CSS 링크 수정
              const links = document.querySelectorAll('link[rel="stylesheet"]');
              links.forEach(link => {
                const href = link.getAttribute('href');
                if (href && href.startsWith('/portfolio/')) {
                  link.href = href.substring('/portfolio'.length);
                }
              });
              
              // JS 스크립트 수정
              const scripts = document.querySelectorAll('script[src]');
              scripts.forEach(script => {
                const src = script.getAttribute('src');
                if (src && src.startsWith('/portfolio/')) {
                  script.src = src.substring('/portfolio'.length);
                }
              });
            });
            
            // 페이지 리로드하여 수정된 경로로 리소스 로드
            await page.reload({ waitUntil: 'networkidle0', timeout: 60000 });
            
            // 한글 폰트를 명시적으로 CSS에 주입
            await page.addStyleTag({
              content: `
                * {
                  font-family: "Noto Sans CJK KR", "Noto Sans KR", "Noto Sans", "Malgun Gothic", "Apple SD Gothic Neo", sans-serif !important;
                }
                code, pre, kbd, samp {
                  font-family: "Noto Sans Mono CJK KR", "Noto Sans Mono", "Consolas", "Monaco", monospace !important;
                }
              `
            });
            
            // 추가 대기 (리소스 로딩 완료 대기)
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // 모든 이미지가 로드될 때까지 대기 및 확인
            const imageLoadStatus = await page.evaluate(async () => {
              const images = Array.from(document.images);
              const loadPromises = images.map(img => {
                if (img.complete && img.naturalHeight !== 0) {
                  return Promise.resolve({ src: img.src, loaded: true });
                }
                return new Promise((resolve) => {
                  const timeout = setTimeout(() => {
                    resolve({ src: img.src, loaded: false, error: 'timeout' });
                  }, 10000);
                  img.onload = () => {
                    clearTimeout(timeout);
                    resolve({ src: img.src, loaded: true });
                  };
                  img.onerror = () => {
                    clearTimeout(timeout);
                    resolve({ src: img.src, loaded: false, error: 'load error' });
                  };
                });
              });
              
              const results = await Promise.all(loadPromises);
              return results;
            });
            
            // 이미지 로딩 상태 로그
            console.log('Image load status:');
            imageLoadStatus.forEach(status => {
              if (!status.loaded) {
                console.log(`  Failed: ${status.src} - ${status.error || 'unknown error'}`);
              }
            });
            
            // 이미지가 base64로 로드되었는지 확인하고, 실패한 이미지는 재시도
            await page.evaluate(() => {
              const images = document.querySelectorAll('img');
              images.forEach(img => {
                // 이미지가 로드되지 않았으면 재시도
                if (!img.complete || img.naturalHeight === 0) {
                  const src = img.src;
                  img.src = '';
                  img.src = src;
                }
              });
            });
            
            // 이미지 재로딩 대기
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // 실패한 이미지를 base64로 변환하여 포함
            await page.evaluate(async () => {
              const images = document.querySelectorAll('img');
              for (const img of images) {
                try {
                  // 이미지가 로드되지 않았거나 에러가 있는 경우
                  if (!img.complete || img.naturalHeight === 0 || img.src.startsWith('http')) {
                    // fetch를 사용하여 이미지를 base64로 변환
                    const response = await fetch(img.src);
                    if (response.ok) {
                      const blob = await response.blob();
                      const reader = new FileReader();
                      const base64 = await new Promise((resolve, reject) => {
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                      });
                      img.src = base64;
                    }
                  }
                } catch (e) {
                  console.log(`Failed to convert image to base64: ${img.src}`, e);
                }
              }
            });
            
            // base64 변환 후 추가 대기
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // PDF 생성 전 최종 확인
            const finalCheck = await page.evaluate(() => {
              return {
                images: document.images.length,
                loadedImages: Array.from(document.images).filter(img => img.complete && img.naturalHeight > 0).length,
                fonts: Array.from(document.fonts).map(f => f.family),
                bodyText: document.body.innerText.substring(0, 100) // 한글 텍스트 확인용
              };
            });
            console.log('Final check:', JSON.stringify(finalCheck, null, 2));
            
            // 디버깅을 위한 스크린샷 저장 (선택사항)
            // await page.screenshot({ path: 'debug-screenshot.png', fullPage: true });
            
            // PDF 생성 옵션 (폰트와 이미지가 제대로 포함되도록 설정)
            await page.pdf({
              path: 'portfolio.pdf',
              format: 'A4',
              printBackground: true,
              preferCSSPageSize: false,
              displayHeaderFooter: false,
              margin: {
                top: '20mm',
                right: '15mm',
                bottom: '20mm',
                left: '15mm'
              },
              // 폰트와 이미지 포함을 위한 추가 옵션
              tagged: false,
              outline: false
            });
            
            await browser.close();
            server.close();
            console.log('PDF generated successfully');
          })();
          EOF
          
          # 스크립트 실행
          node generate-pdf.js

      # ============================
      # 6) Copy PDF to public root
      # ============================
      - name: Copy PDF to public root
        run: |
          sudo chown -R $USER:$USER public
          cp portfolio.pdf public/portfolio.pdf

      # ============================
      # 7) Upload artifact for Pages
      # ============================
      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: public

  deploy:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v4
